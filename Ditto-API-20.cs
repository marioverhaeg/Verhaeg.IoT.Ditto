//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace Verhaeg.IoT.Ditto.Api20
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class DittoClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public DittoClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List all available Things</summary>
        /// <param name="ids">Contains a comma separated list of `thingId`s to retrieve in one
        /// single request.</param>
        /// <param name="fields">Contains a comma separated list of fields to be included in the returned
        /// JSON. Attributes can be selected in the same manner.
        /// 
        /// #### Selectable fields
        /// 
        /// * `thingId`
        /// 
        /// * `policyId`
        /// 
        /// * `_policy`
        /// 
        ///  Specifically selects the policy of the Thing. (The policy is not contained in the returned JSON per default.)
        /// 
        /// * `attributes`
        /// 
        ///   Supports selecting arbitrary sub-fields by using a comma separated list:
        ///     * several attribute paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///       For example:
        ///         * `?fields=attributes/model` would select only `model` attribute value (if present)
        ///         * `?fields=attributes/model,attributes/make` would select only `model` and `make` attribute values (if present)
        /// 
        ///   Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
        ///     * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///     * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///       For example:
        ///        * `?fields=attributes(model,make)` would select only `model` and `make` attribute values (if present)
        ///        * `?fields=attributes(location/longitude)` would select the `longitude` value inside the `location` object
        ///        * `?fields=attributes/address/postal(city,street)` would select the `city` and `street` values inside the `postal` object inside the `address` object
        /// 
        /// * `definition`
        /// 
        /// * `features`
        /// 
        ///   Supports selecting arbitrary fields in features similar to `attributes` (see also Features documentation for more details)
        /// 
        /// * `_namespace`
        /// 
        ///   Specifically selects the namespace also contained in the `thingId`
        /// 
        /// * `_revision`
        /// 
        ///   Specifically selects the revision of the Thing. The revision is a counter which is incremented on each modification of a Thing.
        /// 
        /// * `_modified`
        /// 
        ///   Specifically selects the modified timestamp of the Thing in ISO-8601 UTC format. The timestamp is set on each modification of a Thing.
        /// 
        /// #### Examples
        /// 
        /// * `?fields=thingId,attributes,features`
        /// 
        /// * `?fields=attributes(model,make),features`
        /// 
        /// *
        /// `?fields=thingId,attributes/location/longitude,attributes/address(city,street)`</param>
        /// <returns>The successfully completed request contains as its result the first
        /// 200 for the user available Things, sorted by their `thingId`.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Thing>> ThingsAllAsync(string ids, string fields = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (ids == null)
                throw new System.ArgumentNullException("ids");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things?");
            urlBuilder_.Append(System.Uri.EscapeDataString("ids") + "=").Append(System.Uri.EscapeDataString(ConvertToString(ids, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Thing>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. At least one of the defined\nquery parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "414")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The request could not be completed due to an URI length exceeding 8k\ncharacters.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<Thing>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new Thing</summary>
        /// <param name="body">JSON representation of the Thing to be created.</param>
        /// <returns>The Thing was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Thing> ThingsAsync(NewThing body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Thing>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Possible reasons:\n\n  * the `thingId` was wrongly set in the request body\n  * the JSON of the Thing to be created was invalid", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either\n  * as the caller would not have access to the thing after creating it with the given policy.\n  * as the caller had insufficient permissions.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as either:\n  * the referenced thing does not exist.\n  * the caller had insufficient permissions to read the referenced thing.\n  * the Policy that should be copied does not exist.\n  * the caller had insufficient permissions to read the Policy that should be copied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Thing);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="fields">Contains a comma separated list of fields to be included in the returned
        /// JSON. Attributes can be selected in the same manner.
        /// 
        /// #### Selectable fields
        /// 
        /// * `thingId`
        /// 
        /// * `policyId`
        /// 
        /// * `_policy`
        /// 
        ///  Specifically selects the policy of the Thing. (The policy is not contained in the returned JSON per default.)
        /// 
        /// * `attributes`
        /// 
        ///   Supports selecting arbitrary sub-fields by using a comma separated list:
        ///     * several attribute paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///       For example:
        ///         * `?fields=attributes/model` would select only `model` attribute value (if present)
        ///         * `?fields=attributes/model,attributes/make` would select only `model` and `make` attribute values (if present)
        /// 
        ///   Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
        ///     * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///     * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///       For example:
        ///        * `?fields=attributes(model,make)` would select only `model` and `make` attribute values (if present)
        ///        * `?fields=attributes(location/longitude)` would select the `longitude` value inside the `location` object
        ///        * `?fields=attributes/address/postal(city,street)` would select the `city` and `street` values inside the `postal` object inside the `address` object
        /// 
        /// * `definition`
        /// 
        /// * `features`
        /// 
        ///   Supports selecting arbitrary fields in features similar to `attributes` (see also Features documentation for more details)
        /// 
        /// * `_namespace`
        /// 
        ///   Specifically selects the namespace also contained in the `thingId`
        /// 
        /// * `_revision`
        /// 
        ///   Specifically selects the revision of the Thing. The revision is a counter which is incremented on each modification of a Thing.
        /// 
        /// * `_modified`
        /// 
        ///   Specifically selects the modified timestamp of the Thing in ISO-8601 UTC format. The timestamp is set on each modification of a Thing.
        /// 
        /// #### Examples
        /// 
        /// * `?fields=thingId,attributes,features`
        /// 
        /// * `?fields=attributes(model,make),features`
        /// 
        /// *
        /// `?fields=thingId,attributes/location/longitude,attributes/address(city,street)`</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "rev:4711"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned the specific Thing.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Thing> Things2Async(string thingId, string fields = null, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Thing>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor one of the defined query parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Thing);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update a Thing with a specified ID</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "rev:4711"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <param name="body">JSON representation of the Thing to be modified.</param>
        /// <returns>The Thing was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Thing> Things3Async(string thingId, string if_Match = null, string if_None_Match = null, NewThing body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201" || status_ == "204")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Thing>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else                        
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON of the Thing to be created/modified was either invalid\nor did contain a `thingId` which did not match the ID in the URL.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either\n  * as the caller would not have access to the thing after creating it with the given policy.\n  * as the caller had insufficient permissions.\n    For modifying an existing Thing an unrestricted `WRITE` permission on the Thing\'s root resource is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as either:\n  * the referenced thing does not exist.\n  * the caller had insufficient permissions to read the referenced thing.\n  * the Policy that should be copied does not exist.\n  * the caller had insufficient permissions to read the Policy that should be copied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Thing);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "rev:4711"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Thing was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Things4Async(string thingId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting an existing Thing an unrestricted `WRITE` permission on the Thing\'s root resource is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve the definition of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned the definition of the specific Thing.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> DefinitionAsync(string thingId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/definition");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor one of the defined query parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update the definition of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The definition was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> Definition2Async(string thingId, string if_Match = null, string if_None_Match = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/definition");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The definition was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid or was not a JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying the definition of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete the definition of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The definition was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Definition3Async(string thingId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/definition");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting the definition of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID or\nits definition was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve the Policy ID of a Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned the Policy ID.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> PolicyIdAsync(string thingId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/policyId");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was not found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update the Policy ID of a Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="body">The Policy ID used for controlling access to this Thing. Managed by
        /// resource `/policies/{policyId}`. The `policyId` has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Policy ID was successfully created - the Thing was migrated to API version 2.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> PolicyId2Async(string thingId, string body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/policyId");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Policy ID was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List all Attributes of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="fields">Contains a comma separated list of fields from the attributes to be
        /// included in the returned JSON.
        /// 
        /// #### Selectable fields
        /// 
        /// Supports selecting arbitrary sub-fields as defined in the attributes by
        /// using a comma separated list:
        ///   * several properties paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///     For example:
        ///       * `?fields=model` would select only `model` attribute value (if present)
        ///       * `?fields=model,make` would select only `model` and `make` attribute values (if present)
        /// 
        /// Supports selecting arbitrary sub-fields of objects by wrapping sub-fields
        /// inside parentheses `( )`:
        ///   * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///   * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///     For example:
        ///      * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` attribute
        /// 
        /// #### Examples
        /// 
        /// * `?fields=model,make,location(longitude,latitude)`
        /// 
        /// * `?fields=listOfAddresses/postal(city,street))`</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Attributes of the specific Thing were successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Attributes> AttributesAsync(string thingId, string fields = null, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/attributes?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Attributes>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Attributes);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update all Attributes of a specific Thing at once</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Attributes were successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Attributes> Attributes2Async(string thingId, string if_Match = null, string if_None_Match = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/attributes");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Attributes>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Attributes were successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid or was not a JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying the Attributes of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Attributes);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all Attributes of a specific Thing at once</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Attributes were successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Attributes3Async(string thingId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/attributes");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting all Attributes of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID or\nits Attributes were not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve a specific Attribute of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="attributePath">The path to the Attribute</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Attribute was successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Attributes4Async(string thingId, string attributePath, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (attributePath == null)
                throw new System.ArgumentNullException("attributePath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/attributes/{attributePath}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attributePath}", System.Uri.EscapeDataString(ConvertToString(attributePath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID or\nthe Attribute at the specified path was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update a specific Attribute of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="attributePath">The path to the Attribute</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Attribute was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Attributes5Async(string thingId, string attributePath, string if_Match = null, string if_None_Match = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (attributePath == null)
                throw new System.ArgumentNullException("attributePath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/attributes/{attributePath}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attributePath}", System.Uri.EscapeDataString(ConvertToString(attributePath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying a single Attribute of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a specific Attribute of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="attributePath">The path to the Attribute</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Attribute was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Attributes6Async(string thingId, string attributePath, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (attributePath == null)
                throw new System.ArgumentNullException("attributePath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/attributes/{attributePath}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{attributePath}", System.Uri.EscapeDataString(ConvertToString(attributePath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting a single Attribute of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID or\nthe Attribute at the specified path was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List all Features of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="fields">Contains a comma separated list of fields from one or more Features to be
        /// included in the returned JSON.
        /// 
        /// #### Selectable fields
        /// 
        /// * `{featureId}` The ID of the Feature to select properties in
        /// 
        ///   * `properties`
        /// 
        ///     Supports selecting arbitrary sub-fields by using a comma separated list:
        ///       * several properties paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///         For example:
        ///           * `?fields={featureId}/properties/color` would select only `color` property value (if present) of the Feature identified with `{featureId}`
        ///           * `?fields={featureId}/properties/color,properties/brightness` would select only `color` and `brightness` property values (if present) of the Feature identified with `{featureId}`
        /// 
        ///     Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
        ///       * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///       * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///         For example:
        ///          * `?fields={featureId}/properties(color,brightness)` would select only `color` and `brightness` property values (if present) of the Feature identified with `{featureId}`
        ///          * `?fields={featureId}/properties(location/longitude)` would select the `longitude` value inside the `location` object of the Feature identified with `{featureId}`
        /// 
        /// 
        /// #### Examples
        /// 
        /// * `?fields=EnvironmentScanner/properties(temperature,humidity)`
        /// 
        /// *
        /// `?fields=EnvironmentScanner/properties(temperature,humidity),Vehicle/properties/configuration`</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The list of Features of the specific Thing were successfully
        /// retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, Feature>> FeaturesAsync(string thingId, string fields = null, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, Feature>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined query parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found or the Features have not been defined.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.IDictionary<string, Feature>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify all Features of a specific Thing at once</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="body">JSON object of the Features to be modified at once. It can be also
        /// `null` or an empty object `{}` (all features cleared).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Features were successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, Feature>> Features2Async(string thingId, System.Collections.Generic.IDictionary<string, Feature> body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, Feature>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Features were successfully modified.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid or was not a JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying all features of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.IDictionary<string, Feature>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all Features of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Features were successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Features3Async(string thingId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting all features of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found or the Features have not been defined.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve a specific Feature of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="fields">Contains a comma separated list of fields from the selected Feature to be
        /// included in the returned JSON.
        /// 
        /// #### Selectable fields
        /// 
        /// * `properties`
        /// 
        ///   Supports selecting arbitrary sub-fields by using a comma separated list:
        ///     * several properties paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///       For example:
        ///         * `?fields=properties/color` would select only `color` property value (if present)
        ///         * `?fields=properties/color,properties/brightness` would select only `color` and `brightness` property values (if present)
        /// 
        ///   Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
        ///     * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///     * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///       For example:
        ///        * `?fields=properties(color,brightness)` would select only `color` and `brightness` property values (if present)
        ///        * `?fields=properties(location/longitude)` would select the `longitude` value inside the `location` object
        /// 
        /// #### Examples
        /// 
        /// * `?fields=properties(color,brightness)`</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Feature was successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Feature> Features4Async(string thingId, string featureId, string fields = null, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Feature>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined query parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID or\nthe Feature with the specified `featureId` was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Feature);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify a specific Feature of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="body">JSON representation of the Feature to be created/modified. It can also
        /// be `null` or an empty object `{}`.</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Feature was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Feature> Features5Async(string thingId, string featureId, Feature body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Feature>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Feature was successfully modified.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON of the Feature to be created was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying a single feature of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID was\nnot found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Feature);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a specific Feature of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Feature was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Features6Async(string thingId, string featureId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting a single feature of an existing Thing `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing with the given ID or\nthe Feature at the specified path was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List the definition of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The definition was successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DefinitionAllAsync(string thingId, string featureId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/definition");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined query parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The specified Feature has no\ndefinition or the Thing with the specified `thingId` or the Feature\nwith `featureId` was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update the definition of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="body">JSON array of the complete definition to be updated. Consider that the
        /// value has to be a JSON array or `null`. The content of the JSON array
        /// are strings in the format `"namespace:name:version"` which is
        /// enforced.</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The definition was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> Definition4Async(string thingId, string featureId, System.Collections.Generic.IEnumerable<string> body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/definition");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The definition was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying the definition of an existing Feature `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing or the Feature with\nthe given ID was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete the definition of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The definition was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Definition5Async(string thingId, string featureId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/definition");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting the definition of an existing Feature `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The specified Feature has no\ndefinition or the Thing with the specified `thingId` or the Feature\nwith `featureId` was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List all Properties of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="fields">Contains a comma separated list of fields from the properties to be
        /// included in the returned JSON.
        /// 
        /// #### Selectable fields
        /// 
        /// Supports selecting arbitrary sub-fields as defined in the properties by
        /// using a comma separated list:
        ///   * several properties paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///     For example:
        ///       * `?fields=temperature` would select only `temperature` property value (if present)
        ///       * `?fields=temperature,humidity` would select only `temperature` and `humidity` property values (if present)
        /// 
        /// Supports selecting arbitrary sub-fields of objects by wrapping sub-fields
        /// inside parentheses `( )`:
        ///   * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///   * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///     For example:
        ///      * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` property
        /// 
        /// #### Examples
        /// 
        /// * `?fields=temperature,humidity,location(longitude,latitude)`
        /// 
        /// * `?fields=configuration,status(powerConsumption/watts)`</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Properties were successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FeatureProperties> PropertiesAsync(string thingId, string featureId, string fields = null, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/properties?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FeatureProperties>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined query parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The specified Feature has no\nProperties or the Thing with the specified `thingId` or the Feature\nwith `featureId` was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FeatureProperties);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update all Properties of a Feature at once</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="body">JSON object of all Properties to be updated at once. Consider that the
        /// value has to be a JSON object or `null`. We strongly recommend to use
        /// a restricted set of characters for the key (identifier). Currently
        /// these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9\-]*</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Properties were successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FeatureProperties> Properties2Async(string thingId, string featureId, FeatureProperties body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/properties");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FeatureProperties>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Properties were successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying the Properties of an existing Feature `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing or the Feature with\nthe given ID was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FeatureProperties);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete all Properties of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Properties were successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Properties3Async(string thingId, string featureId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/properties");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting the Properties of an existing Feature `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The specified Feature has no\nProperties or the Thing with the specified `thingId` or the Feature\nwith `featureId` was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve a specific Property of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="propertyPath">The path to the Property</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Property was successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Properties4Async(string thingId, string featureId, string propertyPath, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (propertyPath == null)
                throw new System.ArgumentNullException("propertyPath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/properties/{propertyPath}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{propertyPath}", System.Uri.EscapeDataString(ConvertToString(propertyPath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The specified Property or the\nThing with the specified `thingId` or the Feature with `featureId`\nwas not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update a specific Property of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="propertyPath">The path to the Property</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Property was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Properties5Async(string thingId, string featureId, string propertyPath, string if_Match = null, string if_None_Match = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (propertyPath == null)
                throw new System.ArgumentNullException("propertyPath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/properties/{propertyPath}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{propertyPath}", System.Uri.EscapeDataString(ConvertToString(propertyPath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For creating/updating a Property of an existing Feature `WRITE` permission is required.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Thing or the Feature with\nthe given ID was not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a specific Property of a Feature</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="propertyPath">The path to the Property</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Property was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Properties6Async(string thingId, string featureId, string propertyPath, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (propertyPath == null)
                throw new System.ArgumentNullException("propertyPath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/properties/{propertyPath}");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{propertyPath}", System.Uri.EscapeDataString(ConvertToString(propertyPath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The specified Property or the\nThing with the specified `thingId` or the Feature with `featureId`\nwas not found.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Initiates claiming a specific Thing in order to gain access</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="timeout">Contains an optional timeout (in seconds) of how long to wait for the Claim response and therefore block the
        /// HTTP request. Default value (if omitted): 60 seconds. Maximum value: 600 seconds. A value of 0 seconds applies
        /// fire and forget semantics for the message.</param>
        /// <returns>The Claim message was processed successfully and the response body
        /// contains the custom response. The response body may contain
        /// arbitrary data chosen by the recipient. The response code defaults
        /// to `200` but may be chosen by the recipient too.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ClaimAsync(string thingId, int? timeout = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/inbox/claim?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            if (timeout != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timeout") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timeout, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined path parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The size of the send message is larger than the accepted limit of 250 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The user has sent too many requests in a given amount of time (\"rate\nlimiting\").", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send a message TO a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="messageSubject">The subject of the Message - has to conform to RFC-3986 (URI)</param>
        /// <param name="timeout">Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
        /// HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
        /// fire and forget semantics for the message.</param>
        /// <returns>The message was sent but not necessarily received by the Thing (fire and forget).</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task MessagesAsync(string thingId, string messageSubject, int? timeout = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (messageSubject == null)
                throw new System.ArgumentNullException("messageSubject");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/inbox/messages/{messageSubject}?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{messageSubject}", System.Uri.EscapeDataString(ConvertToString(messageSubject, System.Globalization.CultureInfo.InvariantCulture)));
            if (timeout != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timeout") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timeout, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined path parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller does not have `WRITE` permission on the resource message:/inbox/messages/`messageSubject`.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The size of the send message is larger than the accepted limit of 250 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send a message FROM a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="messageSubject">The subject of the Message - has to conform to RFC-3986 (URI)</param>
        /// <param name="timeout">Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
        /// HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
        /// fire and forget semantics for the message.</param>
        /// <returns>The message was sent (fire and forget).</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Messages2Async(string thingId, string messageSubject, int? timeout = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (messageSubject == null)
                throw new System.ArgumentNullException("messageSubject");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/outbox/messages/{messageSubject}?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{messageSubject}", System.Uri.EscapeDataString(ConvertToString(messageSubject, System.Globalization.CultureInfo.InvariantCulture)));
            if (timeout != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timeout") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timeout, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined path parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller does not have `WRITE` permission on the resource message:/outbox/messages/`messageSubject`.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The size of the send message is larger than the accepted limit of 250 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send a message TO a specific Feature of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="messageSubject">The subject of the Message - has to conform to RFC-3986 (URI)</param>
        /// <param name="timeout">Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
        /// HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
        /// fire and forget semantics for the message.</param>
        /// <returns>The message was sent but not necessarily received by the Feature
        /// (fire and forget).</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Messages3Async(string thingId, string featureId, string messageSubject, int? timeout = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (messageSubject == null)
                throw new System.ArgumentNullException("messageSubject");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/inbox/messages/{messageSubject}?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{messageSubject}", System.Uri.EscapeDataString(ConvertToString(messageSubject, System.Globalization.CultureInfo.InvariantCulture)));
            if (timeout != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timeout") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timeout, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined path parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller does not have `WRITE` permission on the resource message:/features/`featureId`/inbox/messages/`messageSubject`.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The size of the send message is larger than the accepted limit of 250 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send a message FROM a specific Feature of a specific Thing</summary>
        /// <param name="thingId">The ID of the Thing has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="featureId">The ID of the Feature - has to conform to RFC-3986 (URI)</param>
        /// <param name="messageSubject">The subject of the Message - has to conform to RFC-3986 (URI)</param>
        /// <param name="timeout">Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
        /// HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
        /// fire and forget semantics for the message.</param>
        /// <returns>The message was sent (fire and forget).</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Messages4Async(string thingId, string featureId, string messageSubject, int? timeout = null, object body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (thingId == null)
                throw new System.ArgumentNullException("thingId");

            if (featureId == null)
                throw new System.ArgumentNullException("featureId");

            if (messageSubject == null)
                throw new System.ArgumentNullException("messageSubject");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("things/{thingId}/features/{featureId}/outbox/messages/{messageSubject}?");
            urlBuilder_.Replace("{thingId}", System.Uri.EscapeDataString(ConvertToString(thingId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{featureId}", System.Uri.EscapeDataString(ConvertToString(featureId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{messageSubject}", System.Uri.EscapeDataString(ConvertToString(messageSubject, System.Globalization.CultureInfo.InvariantCulture)));
            if (timeout != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("timeout") + "=").Append(System.Uri.EscapeDataString(ConvertToString(timeout, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `thingId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor at least one of the defined path parameters was invalid.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller does not have `WRITE` permission on the resource message:/features/`featureId`/outbox/messages/`messageSubject`.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The size of the send message is larger than the accepted limit of 250 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve a specific Policy</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "rev:4711"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned completed and returned is the
        /// Policy.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Policy> PoliciesAsync(string policyId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Policy>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Policy);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or update a Policy with a specified ID</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="body">JSON representation of the Policy.
        /// 
        /// 
        /// Use the placeholder `{{ request:subjectId }}` in order to let the
        /// backend insert the authenticated subjectId of the HTTP request.</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "rev:4711"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Policy was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Policy> Policies2Async(string policyId, Policy body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Policy>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Policy was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Policy JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying a complete Policy, `WRITE` permission on the resource `policy:/` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Policy);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a specific Policy</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "rev:4711"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Policy was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Policies3Async(string policyId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Policy JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting an existing Policy, `WRITE` permission on the resource `policy:/` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve the entries of a specific Policy</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned completed and returned are the
        /// Policy entries.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PolicyEntries> EntriesAsync(string policyId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PolicyEntries>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PolicyEntries);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Modify the entries of a specific Policy</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="body">JSON representation of the Policy entries.
        /// 
        /// 
        /// Use the placeholder `{{ request:subjectId }}` in order to let the
        /// backend insert the authenticated subjectId of the HTTP request.</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Policy entries were successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Entries2Async(string policyId, PolicyEntries body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Policy entry JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying the Policy entries of an existing Policy, `WRITE` permission on the resource `policy:/entries` is required is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve one Policy entry of a Policy for a specific label</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned completed and returned is the
        /// Policy entry.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PolicyEntry> Entries3Async(string policyId, string label, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PolicyEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID or\nthe Policy entry was not found in the context of the authenticated\nuser.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PolicyEntry);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify one Policy entry of a Policy for a specific label</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="body">JSON representation of the Policy entry.
        /// 
        /// 
        /// Use the placeholder `{{ request:subjectId }}` in order to let the
        /// backend insert the authenticated subjectId of the HTTP request.</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Policy entry was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PolicyEntry> Entries4Async(string policyId, string label, PolicyEntry body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PolicyEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Policy entry was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Policy entry JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying a Policy entry of an existing Policy, `WRITE` permission on the resource `policy:/entries/{label}` is required is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(PolicyEntry);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete one Policy entry of a Policy for a specific label</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Policy entry was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Entries5Async(string policyId, string label, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting a Policy entry of an existing Policy, `WRITE` permission on the resource `policy:/entries/{label}` is required is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve all Subjects of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned. The subjects are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Subjects> SubjectsAsync(string policyId, string label, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/subjects");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Subjects>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID or\nthe Policy entry was not found in the context of the authenticated\nuser.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Subjects);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify all Subjects of a Policy Entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="body">JSON representation of the Subjects.
        /// 
        /// 
        /// Use the placeholder `{{ request:subjectId }}` in order to let the
        /// backend insert the authenticated subjectId of the HTTP request.</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Subjects were successfully created or updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Subjects2Async(string policyId, string label, Subjects body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/subjects");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Subjects JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying Subjects of an existing Policy entry, `WRITE` permission on the resource `policy:/entries/{label}/subjects` is required is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID was\nnot found in the context of the authenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve one specific Subject of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="subjectId">The ID of an (Authorization) Subject</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned completed and returned is the
        /// Subject.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SubjectEntry> Subjects3Async(string policyId, string label, string subjectId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (subjectId == null)
                throw new System.ArgumentNullException("subjectId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/subjects/{subjectId}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subjectId}", System.Uri.EscapeDataString(ConvertToString(subjectId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubjectEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID,\nthe Policy entry or the Subject was not found in the context of the\nauthenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SubjectEntry);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify one specific Subject of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="subjectId">The ID of an (Authorization) Subject</param>
        /// <param name="body">JSON representation of the Subject</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Subject was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SubjectEntry> Subjects4Async(string policyId, string label, string subjectId, SubjectEntry body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (subjectId == null)
                throw new System.ArgumentNullException("subjectId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/subjects/{subjectId}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subjectId}", System.Uri.EscapeDataString(ConvertToString(subjectId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubjectEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Subject was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Subject JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying a Subject of an existing Policy entry, `WRITE` permission on the resource `policy:/entries/{label}/subjects/{subjectId}` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID or\nthe Policy entry was not found in the context of the authenticated\nuser.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SubjectEntry);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete one specific Subject of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="subjectId">The ID of an (Authorization) Subject</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Subject was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Subjects5Async(string policyId, string label, string subjectId, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (subjectId == null)
                throw new System.ArgumentNullException("subjectId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/subjects/{subjectId}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{subjectId}", System.Uri.EscapeDataString(ConvertToString(subjectId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting a Subject of an existing Policy entry, `WRITE` permission on the resource `policy:/entries/{label}/subjects/{subjectId}` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID,\nthe Policy entry or the Subject was not found in the context of the\nauthenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve all Resources of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned. The resources are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Resources> ResourcesAsync(string policyId, string label, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/resources");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Resources>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID or\nthe Policy entry was not found in the context of the authenticated\nuser.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Resources);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify all Resources of a Policy Entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="body">JSON representation of the Resources</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Resources were successfully created or updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Resources2Async(string policyId, string label, Resources body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/resources");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Resources JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying Resources of an existing Policy entry, `WRITE` permission on the resource `policy:/entries/{label}/resources` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID or\nthe Policy entry was not found in the context of the authenticated\nuser.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve one specific Resource of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="resourcePath">The path of an (Authorization) Resource</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The request successfully returned completed and returned is the
        /// Resource.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ResourceEntry> Resources3Async(string policyId, string label, string resourcePath, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (resourcePath == null)
                throw new System.ArgumentNullException("resourcePath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/resources/{resourcePath}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{resourcePath}", System.Uri.EscapeDataString(ConvertToString(resourcePath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResourceEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID,\nthe Policy entry or the Resource was not found in the context of the\nauthenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ResourceEntry);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create or modify one specific Resource of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="resourcePath">The path of an (Authorization) Resource</param>
        /// <param name="body">JSON representation of the Resource</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Resource was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ResourceEntry> Resources4Async(string policyId, string label, string resourcePath, ResourceEntry body, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (resourcePath == null)
                throw new System.ArgumentNullException("resourcePath");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/resources/{resourcePath}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{resourcePath}", System.Uri.EscapeDataString(ConvertToString(resourcePath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResourceEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The Resource was successfully updated.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "304")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The (sub-)resource has not been modified. This happens when you specified a If-None-Match header which\n matches the current ETag of the (sub-)resource.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. Either the `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))\nor the JSON was invalid, or no valid Resource JSON object.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For modifying a Resource of an existing Policy entry, `WRITE` permission on the resource `policy:/entries/{label}/resources/{resourcePath}` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID or\nthe Policy entry was not found in the context of the authenticated\nuser.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "413")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The created or modified entity is larger than the accepted limit of 100 kB.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ResourceEntry);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete one Resource of a Policy entry</summary>
        /// <param name="policyId">The ID of the Policy has to conform to the namespaced entity ID notation
        /// (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</param>
        /// <param name="label">The label of a Policy entry</param>
        /// <param name="resourcePath">The path of an (Authorization) Resource</param>
        /// <param name="if_Match">The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
        ///   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
        ///   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`</param>
        /// <param name="if_None_Match">The `If-None-Match` header which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.</param>
        /// <returns>The Resource was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task Resources5Async(string policyId, string label, string resourcePath, string if_Match = null, string if_None_Match = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (policyId == null)
                throw new System.ArgumentNullException("policyId");

            if (label == null)
                throw new System.ArgumentNullException("label");

            if (resourcePath == null)
                throw new System.ArgumentNullException("resourcePath");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("policies/{policyId}/entries/{label}/resources/{resourcePath}");
            urlBuilder_.Replace("{policyId}", System.Uri.EscapeDataString(ConvertToString(policyId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{label}", System.Uri.EscapeDataString(ConvertToString(label, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{resourcePath}", System.Uri.EscapeDataString(ConvertToString(resourcePath, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-Match", ConvertToString(if_Match, System.Globalization.CultureInfo.InvariantCulture));
                    if (if_None_Match != null)
                        request_.Headers.TryAddWithoutValidation("If-None-Match", ConvertToString(if_None_Match, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The `policyId` does not conform to the namespaced entity ID notation\n(see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed as the caller had insufficient permissions. For deleting a Resource of an existing Policy entry, `WRITE` permission on the resource `policy:/entries/{label}/resources/{resourcePath}` is required without having any revoke.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. The Policy with the given ID,\nthe Policy entry or the Resource was not found in the context of the\nauthenticated user.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, when you\nspecified an If-Match or If-None-Match header which fails the precondition check against the current ETag of\nthe (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a\nfailing If-None-Match header for a read request, status 304 will be returned instead.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Search for Things</summary>
        /// <param name="filter">##### Filter operations:
        /// 
        /// * ```eq({property},{value})```
        /// 
        /// * ```ne({property},{value})```
        /// 
        /// * ```gt({property},{value})```
        /// 
        /// * ```ge({property},{value})```
        /// 
        /// * ```lt({property},{value})```
        /// 
        /// * ```le({property},{value})```
        /// 
        /// * ```in({property},{value},{value},...)```
        /// 
        /// * ```like({property},{value})```
        /// 
        /// * ```exists({property})```
        /// 
        /// 
        /// Note: When using filter operations, only things with the specified properties are returned.
        /// For example, the filter `ne(attributes/owner, "SID123")` will only return things that do have
        /// the `owner` attribute.
        /// 
        /// 
        /// ##### Logical operations:
        /// 
        /// 
        /// * ```and({query},{query},...)```
        /// 
        /// * ```or({query},{query},...)```
        /// 
        /// * ```not({query})```
        /// 
        /// 
        /// ##### Examples:
        /// 
        /// * ```eq(attributes/location,"kitchen")```
        /// 
        /// * ```exists(features/featureId)```
        /// 
        /// * ```and(eq(attributes/location,"kitchen"),eq(attributes/color,"red"))```
        /// 
        /// * ```or(eq(attributes/location,"kitchen"),eq(attributes/location,"living-room"))```</param>
        /// <param name="namespaces">A comma separated list of namespaces. This list is used to limit the query to things in the given namespaces
        /// only. When this parameter is omitted, all namespaces will be queried.
        /// 
        /// 
        /// #### Examples:
        /// 
        /// * `?namespaces=com.example.namespace`
        /// 
        /// * `?namespaces=com.example.namespace1,com.example.namespace2`</param>
        /// <param name="fields">Contains a comma separated list of fields to be included in the returned
        /// JSON. Attributes can be selected in the same manner.
        /// 
        /// #### Selectable fields
        /// 
        /// * `thingId`
        /// 
        /// * `policyId`
        /// 
        /// * `_policy`
        /// 
        ///  Specifically selects the policy of the Thing. (The policy is not contained in the returned JSON per default.)
        /// 
        /// * `attributes`
        /// 
        ///   Supports selecting arbitrary sub-fields by using a comma separated list:
        ///     * several attribute paths can be passed as a comma separated list of JSON pointers (RFC-6901)
        /// 
        ///       For example:
        ///         * `?fields=attributes/model` would select only `model` attribute value (if present)
        ///         * `?fields=attributes/model,attributes/make` would select only `model` and `make` attribute values (if present)
        /// 
        ///   Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
        ///     * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
        ///     * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
        /// 
        ///       For example:
        ///        * `?fields=attributes(model,make)` would select only `model` and `make` attribute values (if present)
        ///        * `?fields=attributes(location/longitude)` would select the `longitude` value inside the `location` object
        ///        * `?fields=attributes/address/postal(city,street)` would select the `city` and `street` values inside the `postal` object inside the `address` object
        /// 
        /// * `definition`
        /// 
        /// * `features`
        /// 
        ///   Supports selecting arbitrary fields in features similar to `attributes` (see also Features documentation for more details)
        /// 
        /// * `_namespace`
        /// 
        ///   Specifically selects the namespace also contained in the `thingId`
        /// 
        /// * `_revision`
        /// 
        ///   Specifically selects the revision of the Thing. The revision is a counter which is incremented on each modification of a Thing.
        /// 
        /// * `_modified`
        /// 
        ///   Specifically selects the modified timestamp of the Thing in ISO-8601 UTC format. The timestamp is set on each modification of a Thing.
        /// 
        /// #### Examples
        /// 
        /// * `?fields=thingId,attributes,features`
        /// 
        /// * `?fields=attributes(model,make),features`
        /// 
        /// *
        /// `?fields=thingId,attributes/location/longitude,attributes/address(city,street)`</param>
        /// <param name="option">Possible values for the parameter:
        /// 
        /// ###### Sort operations
        /// 
        /// * ```sort([+|-]{property})```
        /// * ```sort([+|-]{property},[+|-]{property},...)```
        /// 
        /// ###### Paging operations
        /// 
        /// * ```size({page-size})```  Maximum allowed page-size is `200`.
        /// * ```cursor({cursor-id})```  Start the search from the cursor location. Specify the cursor ID without
        /// quotation marks. Cursor IDs are given in responses and mark the position after the final search result.
        /// The meaning of cursor IDs is unspecified and may change without notice.
        /// 
        /// The paging option `limit({offset},{count})` is deprecated.
        /// It may result in slow queries, time-outs and will be removed eventually.
        /// 
        /// ##### Examples:
        /// 
        /// * ```sort(+thingId)```
        /// * ```sort(-attributes/manufacturer)```
        /// * ```sort(+thingId,-attributes/manufacturer)```
        /// * ```size(10)``` return 10 results
        /// * ```cursor(LOREMIPSUM)```  return results after the position of the cursor `LOREMIPSUM`.
        /// 
        /// ##### Combine:
        /// 
        /// If you need to specify multiple options, when using the swagger UI just write each option in a new line.
        /// When using the plain REST API programmatically,
        /// you will need to separate the options using a comma (,) character.
        /// 
        /// ```size(200),cursor(LOREMIPSUM)```
        /// 
        /// The deprecated paging option `limit` may not combine with the other paging options `size` and `cursor`.</param>
        /// <returns>An array of the matching things.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchResultThings> Things5Async(string filter = null, string namespaces = null, string fields = null, string option = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("search/things?");
            if (filter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("filter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(filter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (namespaces != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("namespaces") + "=").Append(System.Uri.EscapeDataString(ConvertToString(namespaces, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (option != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("option") + "=").Append(System.Uri.EscapeDataString(ConvertToString(option, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchResultThings>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. A provided parameter was in a\nwrong format.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to an invalid authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "504")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request ran out of time to execute on the the back-end. Optimize your query and try again.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchResultThings);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Count Things</summary>
        /// <param name="filter">##### Filter operations:
        /// 
        /// * ```eq({property},{value})```
        /// 
        /// * ```ne({property},{value})```
        /// 
        /// * ```gt({property},{value})```
        /// 
        /// * ```ge({property},{value})```
        /// 
        /// * ```lt({property},{value})```
        /// 
        /// * ```le({property},{value})```
        /// 
        /// * ```in({property},{value},{value},...)```
        /// 
        /// * ```like({property},{value})```
        /// 
        /// * ```exists({property})```
        /// 
        /// 
        /// Note: When using filter operations, only things with the specified properties are returned.
        /// For example, the filter `ne(attributes/owner, "SID123")` will only return things that do have
        /// the `owner` attribute.
        /// 
        /// 
        /// ##### Logical operations:
        /// 
        /// 
        /// * ```and({query},{query},...)```
        /// 
        /// * ```or({query},{query},...)```
        /// 
        /// * ```not({query})```
        /// 
        /// 
        /// ##### Examples:
        /// 
        /// * ```eq(attributes/location,"kitchen")```
        /// 
        /// * ```exists(features/featureId)```
        /// 
        /// * ```and(eq(attributes/location,"kitchen"),eq(attributes/color,"red"))```
        /// 
        /// * ```or(eq(attributes/location,"kitchen"),eq(attributes/location,"living-room"))```</param>
        /// <param name="namespaces">A comma separated list of namespaces. This list is used to limit the query to things in the given namespaces
        /// only. When this parameter is omitted, all namespaces will be queried.
        /// 
        /// 
        /// #### Examples:
        /// 
        /// * `?namespaces=com.example.namespace`
        /// 
        /// * `?namespaces=com.example.namespace1,com.example.namespace2`</param>
        /// <returns>A number indicating the amount of matched things</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<int> CountAsync(string filter = null, string namespaces = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("search/things/count?");
            if (filter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("filter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(filter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (namespaces != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("namespaces") + "=").Append(System.Uri.EscapeDataString(ConvertToString(namespaces, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<int>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed. A provided parameter was in a\nwrong format.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to missing authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request could not be completed due to an invalid authentication.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "504")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdvancedError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<AdvancedError>("The request ran out of time to execute on the the back-end. Optimize your query and try again.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(int);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    return System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Error
    {
        /// <summary>The HTTP status of the error</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }

        /// <summary>The message of the error - what went wrong</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }

        /// <summary>A description how to fix the error or more details</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>A link to further information about the error and how to fix it</summary>
        [Newtonsoft.Json.JsonProperty("href", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Href { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Error FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Error>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AdvancedError
    {
        /// <summary>The HTTP status of the error</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }

        /// <summary>The error code of the occurred exception</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Error { get; set; }

        /// <summary>The message of the error - what went wrong</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }

        /// <summary>A description how to fix the error or more details</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>A link to further information about the error and how to fix it</summary>
        [Newtonsoft.Json.JsonProperty("href", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Href { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static AdvancedError FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AdvancedError>(data);
        }

    }

    /// <summary>Attributes of a Thing: an arbitrary JSON object.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Attributes
    {
        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Attributes FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Attributes>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FeatureDefinition : System.Collections.ObjectModel.Collection<string>
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FeatureDefinition FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeatureDefinition>(data);
        }

    }

    /// <summary>Properties of a Feature: an arbitrary JSON object.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FeatureProperties
    {
        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static FeatureProperties FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeatureProperties>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Feature
    {
        [Newtonsoft.Json.JsonProperty("definition", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FeatureDefinition Definition { get; set; }

        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FeatureProperties Properties { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Feature FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Feature>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchResultThings
    {
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Thing> Items { get; set; }

        [Newtonsoft.Json.JsonProperty("cursor", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cursor { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SearchResultThings FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SearchResultThings>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NewThing
    {
        [Newtonsoft.Json.JsonProperty("_policy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InitialPolicy _policy { get; set; }

        /// <summary>This field may contain the Policy ID of an existing Policy.
        /// The Policy is copied and used for this newly created Thing. This field may also contain a placeholder
        /// reference to a Thing in the format `{{ ref:things/[thingId]/policyId }}` where you need to replace `[thingId]`
        /// with a valid Thing ID. The newly created Thing will then obtain a copy of the Policy of the referenced Thing.
        /// In the case of using a reference, the caller needs to have READ access to both the Thing and the Policy of the Thing.
        /// In the case of using an explicit policy id to copy from, the caller needs to have READ access to the Policy.
        /// If you want to specify a Policy ID for the copied policy, use the policyId field.
        /// This field must not be used together with the field `_policy`. If you specify both `_policy` and
        /// `_copyPolicyFrom` this will lead to an error response.</summary>
        [Newtonsoft.Json.JsonProperty("_copyPolicyFrom", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _copyPolicyFrom { get; set; }

        /// <summary>The Policy ID used for controlling access to this Thing. Managed by
        /// resource `/policies/{policyId}`.</summary>
        [Newtonsoft.Json.JsonProperty("policyId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PolicyId { get; set; }

        [Newtonsoft.Json.JsonProperty("definition", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)")]
        public string Definition { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Attributes Attributes { get; set; }

        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Features Features { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static NewThing FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<NewThing>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Thing 
    {
        /// <summary>Unique identifier representing the Thing, has to conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</summary>
        [Newtonsoft.Json.JsonProperty("thingId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ThingId { get; set; }

        /// <summary>The policy ID used for controlling access to this thing, managed by resource `/policies/{policyId}`, has to conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).</summary>
        [Newtonsoft.Json.JsonProperty("policyId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PolicyId { get; set; }

        [Newtonsoft.Json.JsonProperty("definition", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)")]
        public string Definition { get; set; }

        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Attributes Attributes { get; set; } = new Attributes();

        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Features Features { get; set; } = new Features();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Thing FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Thing>(data);
        }

    }

    /// <summary>Policy consisting of PolicyEntries</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Policy
    {
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyEntries Entries { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Policy FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Policy>(data);
        }

    }

    /// <summary>The initial Policy when creating a Thing. This will create a separate Policy entity managed by resource `/policies/{thingId}`.
    /// Use the placeholder `{{ request:subjectId }}` in order to let the backend insert the authenticated subjectId of the HTTP request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class InitialPolicy
    {
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyEntries Entries { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static InitialPolicy FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<InitialPolicy>(data);
        }

    }

    /// <summary>PolicyEntries containing one PolicyEntry for each arbitrary `label` key</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PolicyEntries
    {
        [Newtonsoft.Json.JsonProperty("label1", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyEntry Label1 { get; set; }

        [Newtonsoft.Json.JsonProperty("labelN", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyEntry LabelN { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PolicyEntries FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PolicyEntries>(data);
        }

    }

    /// <summary>Single Policy entry containing Subjects and Resources.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PolicyEntry
    {
        [Newtonsoft.Json.JsonProperty("subjects", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Subjects Subjects { get; set; } = new Subjects();

        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Resources Resources { get; set; } = new Resources();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static PolicyEntry FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<PolicyEntry>(data);
        }

    }

    /// <summary>(Authorization) Subjects containing one SubjectEntry for each arbitrary
    /// `issuer:subjectId` key. `issuer` being one of the following
    /// `iot-permissions`, `iot-things`</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Subjects
    {
        [Newtonsoft.Json.JsonProperty("iot-permissions:subjectId1", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubjectEntry IotPermissions_subjectId1 { get; set; }

        [Newtonsoft.Json.JsonProperty("iot-permissions:subjectIdN", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubjectEntry IotPermissions_subjectIdN { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Subjects FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Subjects>(data);
        }

    }

    /// <summary>Single (Authorization) Subject entry holding its type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SubjectEntry
    {
        /// <summary>The type is offered only for documentation purposes. You are not restricted to any specific types, but we recommend to use it to specify the kind of the subject as shown in our examples.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static SubjectEntry FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SubjectEntry>(data);
        }

    }

    /// <summary>(Authorization) Resources containing one ResourceEntry for each
    /// `type:path` key, `type` being one of the following `thing`, `policy`,
    /// `message`</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Resources
    {
        [Newtonsoft.Json.JsonProperty("thing:/", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceEntry Thing__ { get; set; }

        [Newtonsoft.Json.JsonProperty("thing:/attributes/some/path", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceEntryRestricted Thing__attributes_some_path { get; set; }

        [Newtonsoft.Json.JsonProperty("policy:/", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceEntry Policy__ { get; set; }

        [Newtonsoft.Json.JsonProperty("message:/", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceEntry Message__ { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Resources FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Resources>(data);
        }

    }

    /// <summary>Single (Authorization) Resource entry defining permissions per effect.
    /// Allowed effects are `grant` and `revoke`.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ResourceEntry
    {
        [Newtonsoft.Json.JsonProperty("grant", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Permission> Grant { get; set; }

        [Newtonsoft.Json.JsonProperty("revoke", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Permission> Revoke { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ResourceEntry FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ResourceEntry>(data);
        }

    }

    /// <summary>Single (Authorization) Resource entry defining permissions per effect.
    /// Allowed effects are `grant` and `revoke`.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ResourceEntryRestricted
    {
        [Newtonsoft.Json.JsonProperty("grant", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Permission> Grant { get; set; }

        [Newtonsoft.Json.JsonProperty("revoke", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Permission> Revoke { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static ResourceEntryRestricted FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ResourceEntryRestricted>(data);
        }

    }

    /// <summary>A Permission allows a certain action on an entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Permission
    {
        [System.Runtime.Serialization.EnumMember(Value = @"READ")]
        READ = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"WRITE")]
        WRITE = 1,

    }

    /// <summary>List of Features where the key represents the `featureId` of each Feature.
    /// The `featureId` key must be unique in the list.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.18.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Features : System.Collections.Generic.Dictionary<string, Feature>
    {
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }

        public static Features FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Features>(data);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore 472
#pragma warning restore 114
#pragma warning restore 108